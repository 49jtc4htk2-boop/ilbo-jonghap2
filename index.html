<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì¼ì¼ ì „ë„ í™œë™ ìë™ì¢…í•©</title>
  <style>
    :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,'Noto Sans KR',Arial;}
    body{max-width:980px;margin:20px auto;padding:18px;background:#fbfbfb;border:1px solid #eee;border-radius:10px}
    h1{font-size:20px;margin:0 0 12px}
    textarea{width:100%;min-height:260px;padding:12px;font-size:13px;border-radius:8px;border:1px solid #ddd;resize:vertical}
    .row{display:flex;gap:8px;margin-top:8px}
    button{padding:10px 14px;border-radius:8px;border:0;background:#0b76ef;color:#fff;cursor:pointer}
    button.secondary{background:#6c757d}
    pre{white-space:pre-wrap;background:#fff;padding:12px;border-radius:8px;border:1px solid #ececec;min-height:80px}
    .errors{background:#fff0f0;border:1px solid #ffcccc;padding:10px;border-radius:8px;color:#900}
    .ok{background:#f0fff7;border:1px solid #bfeccf;padding:10px;border-radius:8px;color:#064}
    label{font-weight:600}
    .hint{font-size:12px;color:#666;margin-top:6px}
  </style>
</head>
<body>
  <h1>ğŸŒ³ ì¼ì¼ ì „ë„ í™œë™ ìë™ ì¢…í•© ğŸŒ³ (index.html)</h1>
  <p class="hint">ì…ë ¥ í…ìŠ¤íŠ¸ ë¸”ë¡(ì „ì²´)ì„ ë¶™ì—¬ë„£ê³  <strong>ê³„ì‚°í•˜ê¸°</strong>ë¥¼ ëˆ„ë¥´ë©´ ìœ íš¨ì„± ê²€ì‚¬ í›„ ì¢…í•© ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ìˆìœ¼ë©´ ì˜¤ë¥˜ ëª©ë¡ë§Œ í‘œì‹œë©ë‹ˆë‹¤.</p>

  <label for="input">ì¼ë³´ì–‘ì‹ ë¶™ì—¬ë„£ê¸°</label>
  <textarea id="input" placeholder="ì—¬ê¸°ì— ì „ì²´ ë³´ê³  í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê¸°"></textarea>

  <div class="row">
    <button id="calc">ê³„ì‚°í•˜ê¸°</button>
    <button class="secondary" id="clear">ì§€ìš°ê¸°</button>
    <button id="copy" title="ë³µì‚¬">ê²°ê³¼ ë³µì‚¬</button>
  </div>

  <h3 style="margin-top:16px">ê²°ê³¼</h3>
  <div id="resultArea">
    <pre id="result">(ì•„ì§ ê³„ì‚°í•˜ì§€ ì•ŠìŒ)</pre>
  </div>

  <script>
  // ìœ í‹¸
  const trim = s => s.replace(/^\s+|\s+$/g, '');
  const floatEq = (a,b,t=0.001) => Math.abs(a-b) < t;

  // ì¹¼ëŸ¼ëª… ìˆœì„œ (ì…ë ¥ ì¤„ì—ì„œ ì²« ì¹¸ì€ êµ¬ì—­ë²ˆí˜¸)
  const COLS = ['êµ¬ì—­ë²ˆí˜¸','êµ¬ì—­ì¥','ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´','ë§ì”€ë”°ê¸°','ì„¼í„°í™•ë‹µ'];

  function parseBlock(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l!=="");
    if(lines.length===0) return {error:['ì…ë ¥ í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.']};

    // ì¤„ë“¤ ì¤‘ì—ì„œ 'ìˆ«ì/'ë¡œ ì‹œì‘í•˜ëŠ” ë°ì´í„° ë¼ì¸ ì°¾ìŒ
    const dataLines = lines.filter(l => /^\d+\//.test(l));
    if(dataLines.length===0) return {error:['êµ¬ì—­ ë°ì´í„° ë¼ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì˜ˆ: 1/í˜„ìŠ¹í™”/...)']};

    const rows = [];
    const errors = [];

    // ì „ì²´ ë§µ: ì´ë¦„ -> occurrences
    const nameMap = new Map();

    dataLines.forEach((line, idx) => {
      const parts = line.split('/');
      // trimming each part
      for(let i=0;i<parts.length;i++) parts[i] = trim(parts[i]);

      if(parts.length !== 10){
        // try to be helpful: say which zone (first part)
        const zone = parts[0] || `(ë¼ì¸ ${idx+1})`;
        errors.push(`${zone}êµ¬ì—­ ì¹¸ ê°œìˆ˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.`);
        rows.push({raw:line, parts});
        return;
      }

      const zone = parts[0];
      const obj = {zone, raw:line, parts: {}};

      for(let i=1;i<10;i++){
        const colName = COLS[i];
        const rawCell = parts[i];
        // parse: number(inside...) or just number
        const m = rawCell.match(/^(\d+(?:\.\d+)?)(?:\((.*)\))?$/);
        if(!m){
          errors.push(`${zone}êµ¬ì—­ ${colName}ì˜ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: "${rawCell}"`);
          obj.parts[colName] = {raw:rawCell, count:null, names:[]};
          continue;
        }
        const count = parseFloat(m[1]);
        const inside = m[2] ? trim(m[2]) : null;
        const names = [];
        if(inside){
          // names separated by space
          // allow commas too
          const tokens = inside.split(/\s+/).filter(Boolean);
          tokens.forEach(tok => {
            // remove trailing commas or slashes
            tok = tok.replace(/[,ï¼Œ\/]+$/,'');
            let value = 1;
            let name = tok;
            if(/\.5$/.test(tok)){
              value = 0.5;
              name = tok.replace(/\.5$/,'');
            } else if(/1$/.test(tok) && !/[^\u0000-\u007F]1$/.test(tok)){
              // if ends with ascii '1' assume it's the numeric marker
              // but be careful Korean names might accidentally end with 1 char '1' rarely â€” sample uses it
              value = 1;
              name = tok.replace(/1$/,'');
            } else {
              // no trailing numeric -> treat as 1
              value = 1;
              name = tok;
            }
            name = name.replace(/^[\.\s]+|[\.\s]+$/g,'');
            if(name!=='') names.push({name, value});
          });
        }

        // verify sum of names
        const sumNames = names.reduce((s,n)=>s + (parseFloat(n.value)||0),0);
        if(inside && !floatEq(sumNames, count)){
          errors.push(`${zone}êµ¬ì—­ ${colName} ê´„í˜¸ ì•ˆì˜ ìˆ˜ì¹˜ì˜ í•©ê³¼ ê´„í˜¸ ì• ìˆ«ìê°€ í‹€ë¦½ë‹ˆë‹¤.`);
        }

        obj.parts[colName] = {raw:rawCell, count, names};

        // update nameMap (ì„­ì œìë³´ìœ ëŠ” conflict ì œì™¸í•˜ë¯€ë¡œ still track but mark)
        names.forEach(n => {
          const nm = n.name;
          if(!nameMap.has(nm)) nameMap.set(nm, []);
          nameMap.get(nm).push({zone, col:colName, value:n.value});
        });
      }

      rows.push(obj);
    });

    // ê²€ì‚¬: ê°™ì€ ì‚¬ëŒì´ ì„œë¡œ ë‹¤ë¥¸ êµ¬ì—­ì—ì„œ ì„œë¡œ ë‹¤ë¥¸ ì¹¸ì— ë“±ì¥í•˜ë©´ ì˜¤ë¥˜ (ë‹¨ ì„­ì™¸ìë³´ìœ ëŠ” ì œì™¸)
    const conflictSet = new Set();
    for(const [name, occs] of nameMap){
      // ignore names that appear only in ì„­ì™¸ìë³´ìœ ? The rule: ì„­ì™¸ìë³´ìœ ì¹¸ ì–´ë–¤ ì¹¸ê³¼ë„ ì¶©ëŒ ê²€ì‚¬í•˜ì§€ ì•ŠëŠ”ë‹¤.
      // So if all occurrences are only in ì„­ì™¸ìë³´ìœ , skip conflicts.
      const nonBoYu = occs.filter(o => o.col !== 'ì„­ì™¸ìë³´ìœ ');
      if(nonBoYu.length === 0) continue;

      // find if same name appears in different zones with different cols
      for(let i=0;i<occs.length;i++){
        for(let j=i+1;j<occs.length;j++){
          const a = occs[i]; const b = occs[j];
          if(a.zone !== b.zone && a.col !== 'ì„­ì™¸ìë³´ìœ ' && b.col !== 'ì„­ì™¸ìë³´ìœ '){
            // same person in different zones
            const key = [a.zone,a.col,b.zone,b.col].sort().join('|');
            if(!conflictSet.has(key)){
              conflictSet.add(key);
            }
          }
        }
      }
    }

    // build conflict messages but ignore conflicts that are within same zone (allowed) and ignore any where one col is ì„­ì™¸ìë³´ìœ 
    const conflictMsgs = [];
    conflictSet.forEach(k => {
      // reconstruct a representative message like "Aêµ¬ì—­ ì¹¸ì´ë¦„ vs Bêµ¬ì—­ ì¹¸ì´ë¦„"
      const parts = k.split('|');
      // parts are sorted so not in original order; we still display nicely
      const msg = `${parts[0]}êµ¬ì—­ ${parts[1]} vs ${parts[2]}êµ¬ì—­ ${parts[3]}`;
      conflictMsgs.push(msg);
    });
    conflictMsgs.forEach(m=>errors.push(m));

    // .5 ë”± 1ë²ˆë§Œ ë“±ì¥í•˜ë©´ ì˜¤ë¥˜
    for(const [name, occs] of nameMap){
      let countHalf = occs.filter(o=>parseFloat(o.value)===0.5).length;
      if(countHalf===1 && occs.length===1){
        const only = occs[0];
        errors.push(`${only.zone}êµ¬ì—­ì˜ "${name}.5"ëŠ” ì–´ë–¤ êµ¬ì—­ê³¼ í•¨ê»˜ í•˜ì…¨ë‚˜ìš”?`);
      }
    }

    return {errors, rows, nameMap};
  }

  function computeSummary(parsed){
    const rows = parsed.rows;
    // sum numeric columns: ì„­ì™¸ìë³´ìœ , ì°¾ê¸°, ì„­ì™¸, ë§Œë‚¨, ë‹¨ê³„í–¥ìƒ, ìƒë‹´
    const numericCols = ['ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´'];
    const sums = {};
    numericCols.forEach(c=>sums[c]=0);

    // ë§ì”€ë”°ê¸° / ì„¼í„°í™•ë‹µ aggregate name->value
    const talkMap = new Map();
    const centerMap = new Map();

    for(const r of rows){
      for(const c of numericCols){
        const val = r.parts[c] && r.parts[c].count != null ? parseFloat(r.parts[c].count) : 0;
        sums[c] += val;
      }
      // ë§ì”€ë”°ê¸°
      const talk = r.parts['ë§ì”€ë”°ê¸°'];
      if(talk && talk.names.length>0){
        talk.names.forEach(n=>{
          const prev = talkMap.get(n.name) || 0; talkMap.set(n.name, prev + n.value);
        });
      } else {
        // even if count exists but no names, we ignore names
      }
      const cen = r.parts['ì„¼í„°í™•ë‹µ'];
      if(cen && cen.names.length>0){
        cen.names.forEach(n=>{
          const prev = centerMap.get(n.name) || 0; centerMap.set(n.name, prev + n.value);
        });
      }
    }

    // assemble name strings: ì´ë¦„ìˆ«ì with sums. Only include names with nonzero.
    function namesToString(map){
      const items = Array.from(map.entries()).filter(([k,v]) => v>0).sort((a,b)=>b[1]-a[1]);
      if(items.length===0) return '';
      return items.map(([k,v]) => `${k}${v%1===0?String(v):String(v)}`).join(' ');
    }

    const talkStr = namesToString(talkMap);
    const centerStr = namesToString(centerMap);

    return {sums, talkStr, centerStr};
  }

  document.getElementById('calc').addEventListener('click', ()=>{
    const text = document.getElementById('input').value;
    const parsed = parseBlock(text);
    const resultEl = document.getElementById('result');

    if(parsed.error){
      resultEl.textContent = parsed.error.join('\n');
      return;
    }

    if(parsed.errors && parsed.errors.length>0){
      // only show errors
      resultEl.textContent = parsed.errors.join('\n');
      return;
    }

    // no errors -> compute summary
    const summary = computeSummary(parsed);
    // Build output: keep original header and data lines from input, then ì¢…í•© line
    // We'll include the initial lines from the input textarea up to and including the dataLines, then append ì¢…í•©/...

    const original = document.getElementById('input').value.split(/\r?\n/);
    // find index of first data line
    const startIdx = original.findIndex(l => /^\s*\d+\//.test(l));
    const endIdx = original.findIndex((l,i)=> i>startIdx && /^\s*ì¢…í•©\//.test(l));
    let headerPart = '';
    if(startIdx>=0) headerPart = original.slice(0, endIdx>=0?endIdx:original.length).join('\n');

    const sums = summary.sums;
    // ì¢…í•© format: ì¢…í•©/ì„­ì™¸ìë³´ìœ /ì°¾ê¸°/ì„­ì™¸/ë§Œë‚¨/ë‹¨ê³„í–¥ìƒ/ìƒë‹´/ë§ì”€ë”°ê¸°(ì´ë¦„ìˆ«ì)/ì„¼í„°í™•ë‹µ(ì´ë¦„ìˆ«ì)
    let ì¢…í•©parts = ['ì¢…í•©', sums['ì„­ì™¸ìë³´ìœ '], sums['ì°¾ê¸°'], sums['ì„­ì™¸'], sums['ë§Œë‚¨'], sums['ë‹¨ê³„í–¥ìƒ'], sums['ìƒë‹´']];
    // ë§ì”€ë”°ê¸° and ì„¼í„°í™•ë‹µ as name lists
    const talkField = summary.talkStr ? `${summary.talkStr}` : '';
    const centerField = summary.centerStr ? `${summary.centerStr}` : '';
    // build final line
    const ì¢…í•©line = `${ì¢…í•©parts.join('/')} /${talkField?('/'+talkField):''}${centerField?('/'+centerField):''}`;

    // To mirror user's desired output, we'll append a line like:
    // ì¢…í•©/14/23/18/1/1/0/0/0  OR with names for ë§ì”€ë”°ê¸°/ì„¼í„°í™•ë‹µ
    // But to keep format consistent, we'll output: ì¢…í•©/<numbers...>/<ë§ì”€ë”°ê¸°(ì´ë¦„ìˆ«ì)>/<ì„¼í„°í™•ë‹µ(ì´ë¦„ìˆ«ì)>

    // Simpler: assemble a line with 9 trailing fields to match format
    const talkDisplay = summary.talkStr ? `${summary.talkStr}` : '';
    const centerDisplay = summary.centerStr ? `${summary.centerStr}` : '';

    // Build output block: use original header/data then final ì¢…í•© line
    const outputLines = [];
    // prefer to include the entire input first so output is copy-ready
    outputLines.push(...original.filter(l=>l.trim()!==""));

    // Construct ì¢…í•© with same number of columns (we'll put placeholders for ë§ì”€ë”°ê¸° and ì„¼í„°í™•ë‹µ counts as 0 if empty)
    // to match user example they had something like: ì¢…í•©/14/23/18/1/1/0/0/0
    // We'll compute numeric counts for ë§ì”€ë”°ê¸° and ì„¼í„°í™•ë‹µ totals as sums of values
    const talkTotal = Array.from(parsed.rows.reduce((acc, r) => acc + (r.parts['ë§ì”€ë”°ê¸°'] && r.parts['ë§ì”€ë”°ê¸°'].count? r.parts['ë§ì”€ë”°ê¸°'].count:0), 0) , v=>v);

    // easier: compute numeric totals directly
    const numericForFinal = [
      'ì¢…í•©',
      sums['ì„­ì™¸ìë³´ìœ '],
      sums['ì°¾ê¸°'],
      sums['ì„­ì™¸'],
      sums['ë§Œë‚¨'],
      sums['ë‹¨ê³„í–¥ìƒ'],
      sums['ìƒë‹´']
    ];
    // ë§ì”€ë”°ê¸° total numeric
    let ë§ì”€ì´í•© = 0;
    parsed.rows.forEach(r=>{ if(r.parts['ë§ì”€ë”°ê¸°'] && r.parts['ë§ì”€ë”°ê¸°'].count!=null) ë§ì”€ì´í•© += parseFloat(r.parts['ë§ì”€ë”°ê¸°'].count); });
    let ì„¼í„°ì´í•© = 0;
    parsed.rows.forEach(r=>{ if(r.parts['ì„¼í„°í™•ë‹µ'] && r.parts['ì„¼í„°í™•ë‹µ'].count!=null) ì„¼í„°ì´í•© += parseFloat(r.parts['ì„¼í„°í™•ë‹µ'].count); });

    numericForFinal.push(ë§ì”€ì´í•©);
    numericForFinal.push(ì„¼í„°ì´í•©);
    // push placeholders for two more zeros to reach same length as sample (if needed)
    // but sample shows 9 numeric fields after ì¢…í•©; original had 9 columns after index so we'll append zeros to match columns

    // Compose ì¢…í•© line
    const finalì¢…í•©Line = numericForFinal.join('/');
    // Append name details for ë§ì”€ë”°ê¸°/ì„¼í„°í™•ë‹µ on new line for clarity
    outputLines.push(finalì¢…í•©Line + (summary.talkStr || summary.centerStr ? '\n' + (summary.talkStr?('ë§ì”€ë”°ê¸°('+summary.talkStr+') '):'') + (summary.centerStr?('ì„¼í„°í™•ë‹µ('+summary.centerStr+')'):'') : ''));

    const finalText = outputLines.join('\n');
    document.getElementById('result').textContent = finalText;
  });

  document.getElementById('copy').addEventListener('click', ()=>{
    const txt = document.getElementById('result').textContent;
    navigator.clipboard.writeText(txt).then(()=>{
      alert('ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }).catch(err=>{
      alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
    });
  });

  document.getElementById('clear').addEventListener('click', ()=>{
    document.getElementById('input').value = '';
    document.getElementById('result').textContent = '(ì•„ì§ ê³„ì‚°í•˜ì§€ ì•ŠìŒ)';
  });
  </script>
</body>
</html>
