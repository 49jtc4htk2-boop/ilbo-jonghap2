<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ğŸŒ³0.0 ì¼ì¼ ì „ë„ í™œë™ ë³´ê³  ìë™ì¢…í•©ê³„ì‚°ê¸° ğŸŒ³</title>
  <style>
    body{font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,"Noto Sans KR",Helvetica,Arial,sans-serif; padding:20px; background:#f6f9f6}
    h1{font-size:20px}
    table{border-collapse:collapse;width:100%;background:white}
    th,td{border:1px solid #ddd;padding:6px;text-align:left;font-size:13px}
    th{background:#f0f6f0}
    input[type=text]{width:100%;box-sizing:border-box;padding:6px;border:1px solid #ccc;border-radius:4px}
    .fixed{background:#fff7cc}
    .controls{margin:12px 0}
    .err{color:#9b1c1c;background:#fee; padding:8px;border-radius:6px}
    .ok{color:#064; background:#eef7ee;padding:8px;border-radius:6px}
    pre{background:#111;color:#efe;border-radius:6px;padding:12px;overflow:auto}
    button{padding:8px 12px;border-radius:6px;border:0;background:#2b8a3e;color:white;cursor:pointer}
    button.secondary{background:#555}
  </style>
</head>
<body>
  <h1>ğŸŒ³0.0 ì¼ì¼ ì „ë„ í™œë™ ë³´ê³  ìë™ì¢…í•©ê³„ì‚°ê¸° ğŸŒ³</h1>

  <p>ì•„ë˜ì—ì„œ 1~5 êµ¬ì—­ì˜ <strong>êµ¬ì—­/êµ¬ì—­ì¥(ìˆ˜ì •ë¶ˆê°€)</strong>ì„ ìœ ì§€í•œ ì±„ ë‚˜ë¨¸ì§€ ì¹¸ì„ ì…ë ¥í•˜ì„¸ìš”. ì…ë ¥ í˜•ì‹ ì˜ˆ: <code>í™ê¸¸ë™2, ê¹€ì² ìˆ˜1</code> ë˜ëŠ” <code>3(í™ê¸¸ë™2, ê¹€ì² ìˆ˜1)</code> ë˜ëŠ” <code>í™ê¸¸ë™.5</code> ë“±.</p>

  <table id="report">
    <thead>
      <tr>
        <th>êµ¬ì—­</th>
        <th>êµ¬ì—­ì¥</th>
        <th>ì„­ì™¸ìë³´ìœ </th>
        <th>ë‹¹ì¼ ì°¾ê¸°</th>
        <th>ë‹¹ì¼ ì„­ì™¸</th>
        <th>ë‹¹ì¼ ë§Œë‚¨</th>
        <th>ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨</th>
        <th>ìƒë‹´ë”°ê¸°</th>
        <th>ë§ì”€ë”°ê¸°</th>
        <th>ì„¼í„°í™•ë‹µ</th>
      </tr>
    </thead>
    <tbody>
      <!-- five editable rows, but êµ¬ì—­/êµ¬ì—­ì¥ fixed -->
      <tr data-zone="1"><td class="fixed">1</td><td class="fixed">í˜„ìŠ¹í™”</td>
        <td><input type="text" data-col="ì„­ì™¸ìë³´ìœ "></td>
        <td><input type="text" data-col="ì°¾ê¸°"></td>
        <td><input type="text" data-col="ì„­ì™¸"></td>
        <td><input type="text" data-col="ë§Œë‚¨"></td>
        <td><input type="text" data-col="ë‹¨ê³„í–¥ìƒ"></td>
        <td><input type="text" data-col="ìƒë‹´ë”°ê¸°"></td>
        <td><input type="text" data-col="ë§ì”€ë”°ê¸°"></td>
        <td><input type="text" data-col="ì„¼í„°í™•ë‹µ"></td>
      </tr>
      <tr data-zone="2"><td class="fixed">2</td><td class="fixed">ê¹€ì´ˆì•„</td>
        <td><input type="text" data-col="ì„­ì™¸ìë³´ìœ "></td>
        <td><input type="text" data-col="ì°¾ê¸°"></td>
        <td><input type="text" data-col="ì„­ì™¸"></td>
        <td><input type="text" data-col="ë§Œë‚¨"></td>
        <td><input type="text" data-col="ë‹¨ê³„í–¥ìƒ"></td>
        <td><input type="text" data-col="ìƒë‹´ë”°ê¸°"></td>
        <td><input type="text" data-col="ë§ì”€ë”°ê¸°"></td>
        <td><input type="text" data-col="ì„¼í„°í™•ë‹µ"></td>
      </tr>
      <tr data-zone="3"><td class="fixed">3</td><td class="fixed">ì„¤ì„¸ì§„</td>
        <td><input type="text" data-col="ì„­ì™¸ìë³´ìœ "></td>
        <td><input type="text" data-col="ì°¾ê¸°"></td>
        <td><input type="text" data-col="ì„­ì™¸"></td>
        <td><input type="text" data-col="ë§Œë‚¨"></td>
        <td><input type="text" data-col="ë‹¨ê³„í–¥ìƒ"></td>
        <td><input type="text" data-col="ìƒë‹´ë”°ê¸°"></td>
        <td><input type="text" data-col="ë§ì”€ë”°ê¸°"></td>
        <td><input type="text" data-col="ì„¼í„°í™•ë‹µ"></td>
      </tr>
      <tr data-zone="4"><td class="fixed">4</td><td class="fixed">ê¹€ì„ </td>
        <td><input type="text" data-col="ì„­ì™¸ìë³´ìœ "></td>
        <td><input type="text" data-col="ì°¾ê¸°"></td>
        <td><input type="text" data-col="ì„­ì™¸"></td>
        <td><input type="text" data-col="ë§Œë‚¨"></td>
        <td><input type="text" data-col="ë‹¨ê³„í–¥ìƒ"></td>
        <td><input type="text" data-col="ìƒë‹´ë”°ê¸°"></td>
        <td><input type="text" data-col="ë§ì”€ë”°ê¸°"></td>
        <td><input type="text" data-col="ì„¼í„°í™•ë‹µ"></td>
      </tr>
      <tr data-zone="5"><td class="fixed">5</td><td class="fixed">ì´í™˜í¬</td>
        <td><input type="text" data-col="ì„­ì™¸ìë³´ìœ "></td>
        <td><input type="text" data-col="ì°¾ê¸°"></td>
        <td><input type="text" data-col="ì„­ì™¸"></td>
        <td><input type="text" data-col="ë§Œë‚¨"></td>
        <td><input type="text" data-col="ë‹¨ê³„í–¥ìƒ"></td>
        <td><input type="text" data-col="ìƒë‹´ë”°ê¸°"></td>
        <td><input type="text" data-col="ë§ì”€ë”°ê¸°"></td>
        <td><input type="text" data-col="ì„¼í„°í™•ë‹µ"></td>
      </tr>
    </tbody>
  </table>

  <div class="controls">
    <button id="calc">ì¢…í•© ê³„ì‚°</button>
    <button id="copy" class="secondary">ë³µì‚¬ (ë³´ê³ ì„œ í…ìŠ¤íŠ¸ ë³µì‚¬)</button>
  </div>

  <div id="messages"></div>
  <div id="resultArea"></div>

  <hr>
  <div style="font-size:13px; color:#444">
    <p>1) êµ¬ì—­ì¥ë‹˜ê³¼ ì „ë„íŒŒíŠ¸ ë¶€ê¾¸ë‹˜ì´ ìƒì˜í•´ì„œ ì˜¬ë ¤ì£¼ì„¸ìš”(ì„œë¡œ ê³µìœ í•˜ëŠ” ëŠë‚Œ~)</p>
    <p>2) ì—¬ëŸ¬ êµ¬ì—­ì´ í•¨ê»˜ ë§ºëŠ” ì„­ì™¸ìëŠ” ì¼ë³´ì˜¬ë¦´ë•Œ .5 ë¹¼ë¨¹ì§€ì•Šê²Œ ê°™ì´ ì±™ê²¨ì£¼ì„¸ìš”(íŠ¹íˆë‚˜ ì°¾ì„­^^)</p>

    <p>ğŸ¤© ìµœì†Œ í•˜ë£¨ì— ì°¾ê¸° 5! 5! 5! ğŸ¤©</p>
    <p>ğŸ¤© ìµœì†Œ í•˜ë£¨ì— ì°¾ê¸° 5! 5! 5! ğŸ¤©</p>
    <p>ğŸ¤© ìµœì†Œ í•˜ë£¨ì— ë§Œë‚¨ 2! 2! 2! ğŸ¤©</p>
    <p>ğŸ¤© ìµœì†Œ í•˜ë£¨ì— ë§Œë‚¨ 2! 2! 2! ğŸ¤©</p>
  </div>

<script>
// Parsing helpers
function splitTopLevelComma(s){
  // simple split by comma
  return s.split(',').map(x=>x.trim()).filter(x=>x.length);
}

function parseNameCount(token){
  // token like 'í™ê¸¸ë™2' or 'í™ê¸¸ë™.5' or 'í™ê¸¸ë™' or 'ê¹€ì² ìˆ˜1'
  token = token.trim();
  if(!token) return null;
  // look for trailing number or .5
  const m = token.match(/^(.*?)\s*([0-9]+(\.[05])?)$/);
  if(m){
    const name = m[1].trim();
    const count = parseFloat(m[2]);
    return {name, count};
  }
  // otherwise if ends with .5 explicitly
  const m2 = token.match(/^(.*?)(\.5)$/);
  if(m2){
    return {name: m2[1].trim(), count:0.5};
  }
  // if none, default count 1
  return {name: token, count:1};
}

function parseFieldValue(raw){
  raw = (raw||"").trim();
  if(!raw) return {total:0,items:[],raw:''};
  // case like 2(name1, name2)
  const leadParen = raw.match(/^\s*([0-9]+)\s*\((.*)\)\s*$/);
  if(leadParen){
    const lead = parseInt(leadParen[1],10);
    const inside = leadParen[2];
    const tokens = splitTopLevelComma(inside);
    const items = tokens.map(t=>parseNameCount(t)).filter(Boolean);
    const sumInside = items.reduce((s,it)=>s+it.count,0);
    return {total:lead, items, sumInside, raw};
  }
  // otherwise parse as list of names with optional counts
  const tokens = splitTopLevelComma(raw);
  const items = tokens.map(t=>parseNameCount(t)).filter(Boolean);
  const total = items.reduce((s,it)=>s+it.count,0);
  return {total:total, items, raw};
}

function zoneName(i){ return i.toString(); }

function collectAll(){
  const rows = Array.from(document.querySelectorAll('#report tbody tr'));
  const data = rows.map(r=>{
    const zone = r.getAttribute('data-zone');
    const cols = {};
    Array.from(r.querySelectorAll('input[data-col]')).forEach(inp=>{
      cols[inp.getAttribute('data-col')] = inp.value.trim();
    });
    return {zone, cols};
  });
  return data;
}

function calculate(){
  const data = collectAll();
  const errors = [];
  // 1) Ensure each row has inputs (we have inputs hardcoded), so skip

  // 2) Check parentheses consistency
  data.forEach(d=>{
    for(const [col,v] of Object.entries(d.cols)){
      if(!v) continue;
      const p = parseFieldValue(v);
      if(p.sumInside !== undefined){
        // had leading number with parentheses
        if(p.sumInside !== p.total){
          errors.push(`${d.zone}êµ¬ì—­ ${col} ê´„í˜¸ ì•ˆì˜ ìˆ˜ì¹˜ì˜ í•©ê³¼ ê´„í˜¸ ì• ìˆ«ìê°€ í‹€ë¦½ë‹ˆë‹¤.`);
        }
      }
      // Also check if field contains something like '2(í™ê¸¸ë™2, ê¹€1)' but inner parse failed -> ignore
    }
  });

  // 3) Gather name occurrences
  const occurrences = {}; // name -> array of {zone,col,count,raw}
  const dotHalfCounts = {}; // name -> count of .5 occurrences

  data.forEach(d=>{
    for(const [col,v] of Object.entries(d.cols)){
      if(!v) continue;
      // if field is ì„­ì™¸ìë³´ìœ , we still parse items but NOT use for conflict detection
      const parsed = parseFieldValue(v);
      const items = parsed.items.length? parsed.items : (parsed.raw? [ {name:parsed.raw, count:parsed.total} ] : []);
      items.forEach(it=>{
        const name = it.name;
        const cnt = it.count;
        if(!occurrences[name]) occurrences[name]=[];
        occurrences[name].push({zone:d.zone, col, count:cnt, raw:v});
        if(String(cnt).indexOf('.5')>=0 || cnt===0.5){
          dotHalfCounts[name] = (dotHalfCounts[name]||0)+1;
        }
      });
    }
  });

  // 4) .5 single occurrence check
  for(const [name,cnt] of Object.entries(dotHalfCounts)){
    if(cnt===1){
      // find which zone has it
      const occ = (occurrences[name]||[]).find(o=>o.count===0.5);
      const zone = occ? occ.zone : '0';
      errors.push(`${zone}êµ¬ì—­ì˜ "${name}.5"ëŠ” ì–´ë–¤ êµ¬ì—­ê³¼ í•¨ê»˜ í•˜ì…¨ë‚˜ìš”?`);
    }
  }

  // 5) Conflict: same person in different êµ¬ì—­ AND different ì¹¸ -> error (exclude ì„­ì™¸ìë³´ìœ )
  const conflictSet = new Set();
  for(const [name, list] of Object.entries(occurrences)){
    // ignore if only appears in one zone
    const zones = new Set(list.map(x=>x.zone));
    if(zones.size<=1) continue;
    // if all appearances are in same column across zones => allowed? spec didn't forbid, but it said different êµ¬ì—­ & different ì¹¸ causes error.
    // so detect if there exist two appearances with different zone and different col
    for(let i=0;i<list.length;i++){
      for(let j=i+1;j<list.length;j++){
        const a = list[i], b = list[j];
        if(a.zone !== b.zone && a.col !== b.col){
          // But ignore if either column is 'ì„­ì™¸ìë³´ìœ '
          if(a.col==='ì„­ì™¸ìë³´ìœ ' || b.col==='ì„­ì™¸ìë³´ìœ ') continue;
          const key = [a.zone,a.col,b.zone,b.col,name].sort().join('|');
          if(!conflictSet.has(key)){
            conflictSet.add(key);
            errors.push(`${a.zone}êµ¬ì—­ ${a.col} vs ${b.zone}êµ¬ì—­ ${b.col}`);
          }
        }
      }
    }
  }

  // 6) If any row missing required count of inputs? We always have inputs. But spec says "í•œ ì¤„ì— í•„ìš”í•œ ì¹¸ ê°œìˆ˜ê°€ ë§ì§€ ì•Šìœ¼ë©´" â€” we'll check that there are 8 editable cols per row (we have 8)
  // skip this check since UI ensures presence.

  // If errors exist, show them and stop
  const messages = document.getElementById('messages');
  const resultArea = document.getElementById('resultArea');
  messages.innerHTML = '';
  resultArea.innerHTML = '';
  if(errors.length){
    messages.innerHTML = '<div class="err"><strong>ì˜¤ë¥˜ê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤:</strong><br>' + errors.map(e=>`- ${e}`).join('<br>') + '</div>';
    return;
  }

  // No errors -> compute ì¢…í•©
  // For each column sum numbers (ì„­ì™¸ìë³´ìœ  included), except ë§ì”€ë”°ê¸°/ì„¼í„°í™•ë‹µ need names aggregated
  const colsToSum = ['ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´ë”°ê¸°'];
  const summed = {};
  colsToSum.forEach(c=> summed[c]=0);
  const nameAgg = { 'ë§ì”€ë”°ê¸°':{}, 'ì„¼í„°í™•ë‹µ':{} };

  data.forEach(d=>{
    for(const [col,v] of Object.entries(d.cols)){
      if(!v) continue;
      const p = parseFieldValue(v);
      if(col==='ë§ì”€ë”°ê¸°' || col==='ì„¼í„°í™•ë‹µ'){
        const items = p.items.length? p.items : (p.raw? [{name:p.raw, count:p.total}] : []);
        items.forEach(it=>{
          if(!nameAgg[col][it.name]) nameAgg[col][it.name]=0;
          nameAgg[col][it.name] += it.count;
        });
      } else {
        // numerical sum
        const items = p.items;
        let total = 0;
        if(items && items.length){ total = items.reduce((s,it)=>s+it.count,0); }
        else { total = p.total || 0; }
        summed[col] = (summed[col]||0) + total;
      }
    }
  });

  // build ë§ì”€ë”°ê¸° and ì„¼í„°í™•ë‹µ string: name(count) but requirement: ë§ì”€ë”°ê¸°(ì´ë¦„ìˆ«ì)/ì„¼í„°í™•ë‹µ(ì´ë¦„ìˆ«ì)
  function formatNameAgg(obj){
    const parts = Object.keys(obj).map(n=>`${n}${formatCount(obj[n])}`);
    return parts.join(', ');
  }
  function formatCount(v){
    // if integer, show as integer; if .5 sums to integer? show decimal if needed
    if(Number.isInteger(v)) return v>0?`${v}` : '';
    return `${v}`;
  }

  // Build ì¢…í•© string
  const ì¢…í•©parts = [];
  ì¢…í•©parts.push(`ì¢…í•©/`);
  ì¢…í•©parts.push(`ì„­ì™¸ìë³´ìœ :${summed['ì„­ì™¸ìë³´ìœ ']||0}`);
  ì¢…í•©parts.push(`ì°¾ê¸°:${summed['ì°¾ê¸°']||0}`);
  ì¢…í•©parts.push(`ì„­ì™¸:${summed['ì„­ì™¸']||0}`);
  ì¢…í•©parts.push(`ë§Œë‚¨:${summed['ë§Œë‚¨']||0}`);
  ì¢…í•©parts.push(`ë‹¨ê³„í–¥ìƒ:${summed['ë‹¨ê³„í–¥ìƒ']||0}`);
  ì¢…í•©parts.push(`ìƒë‹´ë”°ê¸°:${summed['ìƒë‹´ë”°ê¸°']||0}`);
  const ë§ì”€Str = formatNameAgg(nameAgg['ë§ì”€ë”°ê¸°']);
  const ì„¼í„°Str = formatNameAgg(nameAgg['ì„¼í„°í™•ë‹µ']);
  ì¢…í•©parts.push(`ë§ì”€ë”°ê¸°(${ë§ì”€Str})`);
  ì¢…í•©parts.push(`ì„¼í„°í™•ë‹µ(${ì„¼í„°Str})`);

  resultArea.innerHTML = '<div class="ok"><strong>ì¢…í•© ê³„ì‚° ê²°ê³¼</strong></div><pre>' + ì¢…í•©parts.join(' / ') + '</pre>';
}

// build report text for copy
function buildReportText(){
  const header = `ğŸŒ³0.0 ì¼ì¼ ì „ë„ í™œë™ ë³´ê³  ğŸŒ³\n\nêµ¬ì—­/êµ¬ì—­ì¥/ì„­ì™¸ìë³´ìœ /ë‹¹ì¼ ì°¾ê¸°/ë‹¹ì¼ ì„­ì™¸/ë‹¹ì¼ ë§Œë‚¨/ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨/ìƒë‹´ë”°ê¸°/ë§ì”€ë”°ê¸°/ì„¼í„°í™•ë‹µ\n\n`;
  const rows = collectAll();
  let body = '';
  rows.forEach(r=>{
    const parts = [];
    parts.push(r.zone);
    // find the fixed êµ¬ì—­ì¥ text from the fixed cell
    const tr = document.querySelector(`#report tbody tr[data-zone=\"${r.zone}\"]`);
    const leader = tr.querySelector('td.fixed:nth-child(2)').textContent.trim();
    parts.push(leader);
    ['ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´ë”°ê¸°','ë§ì”€ë”°ê¸°','ì„¼í„°í™•ë‹µ'].forEach(col=>{
      const v = r.cols[col] || '';
      parts.push(v);
    });
    body += parts.join('/') + '/\n';
  });
  body += 'ì¢…í•©/\n\n1) êµ¬ì—­ì¥ë‹˜ê³¼ ì „ë„íŒŒíŠ¸ ë¶€ê¾¸ë‹˜ì´ ìƒì˜í•´ì„œ ì˜¬ë ¤ì£¼ì„¸ìš”(ì„œë¡œ ê³µìœ í•˜ëŠ” ëŠë‚Œ~)\n2) ì—¬ëŸ¬ êµ¬ì—­ì´ í•¨ê»˜ ë§ºëŠ” ì„­ì™¸ìëŠ” ì¼ë³´ì˜¬ë¦´ë•Œ .5 ë¹¼ë¨¹ì§€ì•Šê²Œ ê°™ì´ ì±™ê²¨ì£¼ì„¸ìš”(íŠ¹íˆë‚˜ ì°¾ì„­^^)\n\nğŸ¤© ìµœì†Œ í•˜ë£¨ì— ì°¾ê¸° 5! 5! 5! ğŸ¤©\nğŸ¤© ìµœì†Œ í•˜ë£¨ì— ì°¾ê¸° 5! 5! 5! ğŸ¤©\nğŸ¤© ìµœì†Œ í•˜ë£¨ì— ë§Œë‚¨ 2! 2! 2! ğŸ¤©\nğŸ¤© ìµœì†Œ í•˜ë£¨ì— ë§Œë‚¨ 2! 2! 2! ğŸ¤©\n';
  return header + body;
}

// Event listeners
document.getElementById('calc').addEventListener('click', calculate);
document.getElementById('copy').addEventListener('click', ()=>{
  const text = buildReportText();
  navigator.clipboard.writeText(text).then(()=>{
    alert('í…ìŠ¤íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë¶™ì—¬ë„£ê¸° í•´ì„œ ê³µìœ í•˜ì„¸ìš”.');
  }).catch(()=>{
    alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ì˜ í…ìŠ¤íŠ¸ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
  });
});

</script>

</body>
</html>
