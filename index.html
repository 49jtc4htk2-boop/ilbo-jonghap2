<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ì¼ì¼ ì „ë„ í™œë™ ì¢…í•© ê³„ì‚°ê¸°</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #f0f8ff; }
  textarea { width: 100%; height: 300px; font-family: monospace; margin-bottom: 10px; }
  button { padding: 10px 20px; font-size: 16px; margin-right: 10px; }
  #result { white-space: pre-wrap; background: #e6f7ff; padding: 10px; border-radius: 5px; margin-top: 10px; }
  .error { color: red; font-weight: bold; }
</style>
</head>
<body>

<h2>ğŸŒ³ ì¼ì¼ ì „ë„ í™œë™ ì¢…í•© ê³„ì‚°ê¸° ğŸŒ³</h2>

<textarea id="input" placeholder="ì—¬ê¸°ì— êµ¬ì—­ ë°ì´í„°ë¥¼ ë¶™ì—¬ë„£ê¸°"></textarea><br>
<button onclick="calculate()">ì¢…í•© ê³„ì‚°</button>
<button onclick="copyResult()">ê²°ê³¼ ë³µì‚¬</button>

<div id="result"></div>

<script>
function calculate() {
    const inputText = document.getElementById('input').value;
    const lines = inputText.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('ğŸŒ³') && !l.startsWith('ì¢…í•©') && !l.startsWith('ğŸ¤©') && !l.startsWith('1)') && !l.startsWith('2)'));
    
    const columns = ['êµ¬ì—­ì¥', 'ì„­ì™¸ìë³´ìœ ', 'ë‹¹ì¼ ì°¾ê¸°', 'ë‹¹ì¼ ì„­ì™¸', 'ë‹¹ì¼ ë§Œë‚¨', 'ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨', 'ìƒë‹´ë”°ê¸°', 'ë§ì”€ë”°ê¸°', 'ì„¼í„°í™•ë‹µ'];
    const errors = [];
    const summary = { 'ë‹¹ì¼ ì°¾ê¸°': 0, 'ë‹¹ì¼ ì„­ì™¸': 0, 'ë‹¹ì¼ ë§Œë‚¨': 0, 'ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨': 0, 'ìƒë‹´ë”°ê¸°': 0, 'ë§ì”€ë”°ê¸°': {}, 'ì„¼í„°í™•ë‹µ': {} };
    
    const nameTracker = {}; // ì´ë¦„ë³„ ë“±ì¥ ì²´í¬ (ë‹¤ë¥¸ êµ¬ì—­ ë‹¤ë¥¸ ì¹¸)
    const singleHalfTracker = {}; // .5 í•œ ë²ˆë§Œ ë“±ì¥ ì²´í¬

    lines.forEach((line, idx) => {
        const parts = line.split('/');
        const zone = parts[0];
        
        columns.forEach((col, cIdx) => {
            const cell = parts[cIdx + 1];
            if (!cell) return;

            // ì„­ì™¸ìë³´ìœ ëŠ” ì˜¤ë¥˜ ì œì™¸
            if (col === 'ì„­ì™¸ìë³´ìœ ') return;

            const match = cell.match(/^([\d.]+)\((.*)\)$/);
            if (!match) return; // ìˆ«ì+ê´„í˜¸ ì—†ëŠ” ê²½ìš° ë¬´ì‹œ

            const num = parseFloat(match[1]);
            const names = match[2].split(' ').filter(n => n);
            const sum = names.reduce((acc, n) => {
                const v = parseFloat(n.split('.').pop()) || 1;
                return acc + v;
            }, 0);

            if (Math.abs(sum - num) > 0.001) {
                errors.push(`${zone}êµ¬ì—­ ${col} í•© ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”`);
            }

            // ì´ë¦„ë³„ ì¤‘ë³µ ì²´í¬ (.5 ë‹¨ í•œ ë²ˆ)
            names.forEach(n => {
                const val = parseFloat(n.split('.').pop()) || 1;
                if (val === 0.5) {
                    if (!singleHalfTracker[n]) singleHalfTracker[n] = [];
                    singleHalfTracker[n].push(zone);
                }

                // ë‹¤ë¥¸ êµ¬ì—­ ë‹¤ë¥¸ ì¹¸ ì²´í¬
                if (!nameTracker[n]) nameTracker[n] = [];
                const prev = nameTracker[n].find(e => e.zone !== zone && e.col !== col);
                if (prev) {
                    errors.push(`${n}: ${prev.col} vs ${col} ì–´ë””ì¸ê°€ìš”`);
                }
                nameTracker[n].push({ zone, col });
            });

            // ì¢…í•© ê³„ì‚°
            if (['ë‹¹ì¼ ì°¾ê¸°','ë‹¹ì¼ ì„­ì™¸','ë‹¹ì¼ ë§Œë‚¨','ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨','ìƒë‹´ë”°ê¸°'].includes(col)) {
                summary[col] += num;
            } else if (col === 'ë§ì”€ë”°ê¸°' || col === 'ì„¼í„°í™•ë‹µ') {
                names.forEach(n => {
                    const key = n.replace(/\.\d+$/, '');
                    const val = parseFloat(n.split('.').pop()) || 1;
                    if (!summary[col][key]) summary[col][key] = 0;
                    summary[col][key] += val;
                });
            }
        });
    });

    // .5 ë‹¨ 1ë²ˆë§Œ ë“±ì¥ ì²´í¬
    for (let n in singleHalfTracker) {
        if (singleHalfTracker[n].length === 1) {
            errors.push(`${singleHalfTracker[n][0]}êµ¬ì—­ì˜ "${n}"ëŠ” ì–´ë–¤ êµ¬ì—­ê³¼ í•¨ê»˜ í•˜ì…¨ë‚˜ìš”?`);
        }
    }

    const resultDiv = document.getElementById('result');
    if (errors.length > 0) {
        resultDiv.innerHTML = errors.map(e => 'âš  ' + e).join('\n');
        resultDiv.classList.add('error');
        return;
    }

    // ìµœì¢… ì¢…í•© ì¶œë ¥
    const final = [
        summary['ë‹¹ì¼ ì°¾ê¸°'],
        summary['ë‹¹ì¼ ì„­ì™¸'],
        summary['ë‹¹ì¼ ë§Œë‚¨'],
        summary['ë‹¹ì¼ ë‹¨ê³„í–¥ìƒ ë§Œë‚¨'],
        summary['ìƒë‹´ë”°ê¸°'],
        Object.values(summary['ë§ì”€ë”°ê¸°']).reduce((a,b)=>a+b,0),
        Object.entries(summary['ë§ì”€ë”°ê¸°']).map(([k,v])=>`${k}${v}`).join(' '),
        Object.values(summary['ì„¼í„°í™•ë‹µ']).reduce((a,b)=>a+b,0),
        Object.entries(summary['ì„¼í„°í™•ë‹µ']).map(([k,v])=>`${k}${v}`).join(' ')
    ];

    // ì¶œë ¥ í˜•ì‹: ìˆ«ì / ìˆ«ì / ... / ë§ˆì§€ë§‰ ìˆ«(ì´ë¦„ìˆ«ì)
    const finalText = `${final[0]}/${final[1]}/${final[2]}/${final[3]}/${final[4]}/${final[5]}/${final[6]} / ${final[7]}(${final[8]})`;
    resultDiv.innerHTML = finalText;
    resultDiv.classList.remove('error');
}

function copyResult() {
    const resultDiv = document.getElementById('result');
    if (!resultDiv.innerText) return;
    navigator.clipboard.writeText(resultDiv.innerText).then(() => {
        alert('ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
    });
}
</script>

</body>
</html>
