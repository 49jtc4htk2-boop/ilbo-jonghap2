<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì¼ì¼ í™œë™ ë³´ê³  ìë™ ì¢…í•© </title>
  <style>
    :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,'Noto Sans KR',Arial;}
    body{max-width:980px;margin:20px auto;padding:18px;background:#fbfbfb;border:1px solid #eee;border-radius:10px}
    h1{font-size:20px;margin:0 0 12px}
    textarea{width:100%;min-height:260px;padding:12px;font-size:13px;border-radius:8px;border:1px solid #ddd;resize:vertical}
    .row{display:flex;gap:8px;margin-top:8px}
    button{padding:10px 14px;border-radius:8px;border:0;background:#0b76ef;color:#fff;cursor:pointer}
    button.secondary{background:#6c757d}
    pre{white-space:pre-wrap;background:#fff;padding:12px;border-radius:8px;border:1px solid #ececec;min-height:80px}
    .errors{background:#fff0f0;border:1px solid #ffcccc;padding:10px;border-radius:8px;color:#900}
    .ok{background:#f0fff7;border:1px solid #bfeccf;padding:10px;border-radius:8px;color:#064}
    label{font-weight:600}
    .hint{font-size:12px;color:#666;margin-top:6px}

    /* ğŸ”¥ ìˆ˜ì •ì¶”ê°€: ì˜¤ë¥˜ ì•ˆë‚´ ë°•ìŠ¤ ìŠ¤íƒ€ì¼ë§ */
    #error-info{
      background:#fff8d1;
      border:2px solid #f1c40f;
      padding:14px;
      border-radius:10px;
      color:#8a6d00;
      font-weight:600;
      font-size:14px;
      margin-top:20px;
      box-shadow:0 3px 6px rgba(0,0,0,0.08);
      animation: pulse 1.4s infinite;
    }
    @keyframes pulse{
      0%{box-shadow:0 0 0 rgba(241,196,15,0.5);}
      50%{box-shadow:0 0 12px rgba(241,196,15,0.9);}
      100%{box-shadow:0 0 0 rgba(241,196,15,0.5);}
    }
  </style>
</head>
<body>
  <h1>ğŸŒ³ ì¼ì¼ ì „ë„ í™œë™ ì¢…í•© ğŸŒ³ </h1>

  <!-- ğŸ”¥ HTML ìˆ˜ì •ë¶€ë¶„: ë¶ˆí•„ìš”í•œ í´ë˜ìŠ¤ ì œê±° -->
  <div id="error-info">
    <strong>â€» ì˜¤ë¥˜ ì•ˆë‚´</strong><br>
    - êµ¬ì—­ë³„ ì¹¸ì´ 10ê°œê°€ ì•„ë‹Œ ê²½ìš°<br>
    - ê´„í˜¸ ì• ìˆ«ìì™€ ê´„í˜¸ ì•ˆ ìˆ«ì í•©ì´ ë‹¤ë¥¸ ê²½ìš°.<br>
    - ë™ì¼ ì¸ë¬¼ì´ ì„œë¡œ ë‹¤ë¥¸ êµ¬ì—­/ì¹¸ì¸ ê²½ìš°<br>
  </div>

  <textarea id="input" placeholder="ì—¬ê¸°ì— ì¼ë³´ ì „ì²´ í…ìŠ¤íŠ¸ ë¶™ì—¬ë„£ê¸°"></textarea>

  <div class="row">
    <button id="calc">ê³„ì‚°í•˜ê¸°</button>
    <button class="secondary" id="clear">ì§€ìš°ê¸°</button>
    <button id="copy" title="ë³µì‚¬">ê²°ê³¼ ë³µì‚¬</button>
  </div>

  <h3 style="margin-top:16px">ê²°ê³¼</h3>
  <div id="resultArea">
  </div>

  <script>
  // ìœ í‹¸
  const trim = s => s.replace(/^\s+|\s+$/g, '');
  const floatEq = (a,b,t=0.001) => Math.abs(a-b) < t;

  // ì¹¼ëŸ¼ëª… ìˆœì„œ (ì…ë ¥ ì¤„ì—ì„œ ì²« ì¹¸ì€ êµ¬ì—­ë²ˆí˜¸)
  const COLS = ['êµ¬ì—­ë²ˆí˜¸','êµ¬ì—­ì¥','ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´','ë§ì”€ë”°ê¸°','ì„¼í„°í™•ë‹µ'];

  function parseBlock(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l!=="");
    if(lines.length===0) return {error:['ì…ë ¥ í…ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.']};

    const dataLines = lines.filter(l => /^\d+\//.test(l));
    if(dataLines.length===0) return {error:['êµ¬ì—­ ë°ì´í„° ë¼ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì˜ˆ: 1/í˜„ìŠ¹í™”/...)']};

    const rows = [];
    const errors = [];
    const nameMap = new Map();

    dataLines.forEach((line, idx) => {
      const parts = line.split('/');
      for(let i=0;i<parts.length;i++) parts[i] = trim(parts[i]);

      if(parts.length !== 10){
        const zone = parts[0] || `(ë¼ì¸ ${idx+1})`;
        errors.push(`${zone}êµ¬ì—­ ì¹¸ ê°œìˆ˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.`);
        rows.push({raw:line, parts});
        return;
      }

      const zone = parts[0];
      const obj = {zone, raw:line, parts: {}};

      for(let i=1;i<10;i++){
        const colName = COLS[i];
        const rawCell = parts[i];

        const m = rawCell.match(/^(\d+(?:\.\d+)?)(?:\((.*)\))?$/);
        if(!m){
          errors.push(`${zone}êµ¬ì—­ ${colName}ì˜ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: "${rawCell}"`);
          obj.parts[colName] = {raw:rawCell, count:null, names:[]};
          continue;
        }
        const count = parseFloat(m[1]);
        const inside = m[2] ? trim(m[2]) : null;
        const names = [];
        if(inside){
          const tokens = inside.split(/\s+/).filter(Boolean);
          tokens.forEach(tok => {
            tok = tok.replace(/[,ï¼Œ\/]+$/,'');
            let value = 1;
            let name = tok;
            if(/\.5$/.test(tok)){
              value = 0.5;
              name = tok.replace(/\.5$/,'');
            } else if(/1$/.test(tok)){
              value = 1;
              name = tok.replace(/1$/,'');
            }
            name = name.replace(/^[\.\s]+|[\.\s]+$/g,'');
            if(name!=='') names.push({name, value});
          });
        }

        const sumNames = names.reduce((s,n)=>s + (parseFloat(n.value)||0),0);
        if(inside && !floatEq(sumNames, count)){
          errors.push(`${zone}êµ¬ì—­ ${colName} ê´„í˜¸ ì•ˆì˜ ìˆ˜ì¹˜ì˜ í•©ê³¼ ê´„í˜¸ ì• ìˆ«ìê°€ í‹€ë¦½ë‹ˆë‹¤.`);
        }

        obj.parts[colName] = {raw:rawCell, count, names};

        names.forEach(n => {
          const nm = n.name;
          if(!nameMap.has(nm)) nameMap.set(nm, []);
          nameMap.get(nm).push({zone, col:colName, value:n.value});
        });
      }

      rows.push(obj);
    });

    // conflict check
    const conflictSet = new Set();
    for(const [name, occs] of nameMap){
      const nonBoYu = occs.filter(o => o.col !== 'ì„­ì™¸ìë³´ìœ ');
      if(nonBoYu.length === 0) continue;

      for(let i=0;i<occs.length;i++){
        for(let j=i+1;j<occs.length;j++){
          const a = occs[i], b = occs[j];
          if(a.zone !== b.zone && a.col !== 'ì„­ì™¸ìë³´ìœ ' && b.col !== 'ì„­ì™¸ìë³´ìœ '){
            const key = [a.zone,a.col,b.zone,b.col].sort().join('|');
            if(!conflictSet.has(key)){
              conflictSet.add(key);
            }
          }
        }
      }
    }
    const conflictMsgs = [];
    conflictSet.forEach(k => {
      const parts = k.split('|');
      const msg = `${parts[0]}êµ¬ì—­ ${parts[1]} vs ${parts[2]}êµ¬ì—­ ${parts[3]}`;
      conflictMsgs.push(msg);
    });
    conflictMsgs.forEach(m=>errors.push(m));

    for(const [name, occs] of nameMap){
      let countHalf = occs.filter(o=>parseFloat(o.value)===0.5).length;
      if(countHalf===1 && occs.length===1){
        const only = occs[0];
        errors.push(`${only.zone}êµ¬ì—­ì˜ "${name}.5"ëŠ” ì–´ë–¤ êµ¬ì—­ê³¼ í•¨ê»˜ í•˜ì…¨ë‚˜ìš”?`);
      }
    }

    return {errors, rows, nameMap};
  }

  function computeSummary(parsed){
    const rows = parsed.rows;
    const numericCols = ['ì„­ì™¸ìë³´ìœ ','ì°¾ê¸°','ì„­ì™¸','ë§Œë‚¨','ë‹¨ê³„í–¥ìƒ','ìƒë‹´'];
    const sums = {};
    numericCols.forEach(c=>sums[c]=0);

    const talkMap = new Map();
    const centerMap = new Map();

    for(const r of rows){
      for(const c of numericCols){
        const val = r.parts[c] && r.parts[c].count != null ? parseFloat(r.parts[c].count) : 0;
        sums[c] += val;
      }

      const talk = r.parts['ë§ì”€ë”°ê¸°'];
      if(talk && talk.names.length>0){
        talk.names.forEach(n=>{
          const prev = talkMap.get(n.name) || 0; 
          talkMap.set(n.name, prev + n.value);
        });
      }

      const cen = r.parts['ì„¼í„°í™•ë‹µ'];
      if(cen && cen.names.length>0){
        cen.names.forEach(n=>{
          const prev = centerMap.get(n.name) || 0; 
          centerMap.set(n.name, prev + n.value);
        });
      }
    }

    function namesToString(map){
      const items = Array.from(map.entries()).filter(([k,v])=>v>0).sort((a,b)=>b[1]-a[1]);
      if(items.length===0) return '';
      return items.map(([k,v]) => `${k}${v}`).join(' ');
    }

    const talkStr = namesToString(talkMap);
    const centerStr = namesToString(centerMap);

    return {sums, talkStr, centerStr};
  }

  document.getElementById('calc').addEventListener('click', ()=>{
    const text = document.getElementById('input').value;
    const parsed = parseBlock(text);

    const resultEl = document.getElementById('result');
    if(parsed.error){
      resultEl.textContent = parsed.error.join('\n');
      return;
    }
    if(parsed.errors && parsed.errors.length>0){
      resultEl.textContent = parsed.errors.join('\n');
      return;
    }

    const summary = computeSummary(parsed);
    const original = document.getElementById('input').value.split(/\r?\n/);

    const outputLines = [];
    outputLines.push(...original.filter(l=>l.trim()!==""));

    const sums = summary.sums;

    let ë§ì”€ì´í•© = 0;
    parsed.rows.forEach(r=>{
      if(r.parts['ë§ì”€ë”°ê¸°'] && r.parts['ë§ì”€ë”°ê¸°'].count!=null)
        ë§ì”€ì´í•© += parseFloat(r.parts['ë§ì”€ë”°ê¸°'].count);
    });
    let ì„¼í„°ì´í•© = 0;
    parsed.rows.forEach(r=>{
      if(r.parts['ì„¼í„°í™•ë‹µ'] && r.parts['ì„¼í„°í™•ë‹µ'].count!=null)
        ì„¼í„°ì´í•© += parseFloat(r.parts['ì„¼í„°í™•ë‹µ'].count);
    });

    const numericFinal = [
      'ì¢…í•©',
      sums['ì„­ì™¸ìë³´ìœ '],
      sums['ì°¾ê¸°'],
      sums['ì„­ì™¸'],
      sums['ë§Œë‚¨'],
      sums['ë‹¨ê³„í–¥ìƒ'],
      sums['ìƒë‹´'],
      ë§ì”€ì´í•©,
      ì„¼í„°ì´í•©
    ];

    const finalLine = numericFinal.join('/');

    outputLines.push(
      finalLine +
      (summary.talkStr || summary.centerStr
        ? '\n' +
          (summary.talkStr?('ë§ì”€ë”°ê¸°('+summary.talkStr+') '):'') +
          (summary.centerStr?('ì„¼í„°í™•ë‹µ('+summary.centerStr+')'):'')
        : '')
    );

    document.getElementById('result').textContent = outputLines.join('\n');
  });

  document.getElementById('copy').addEventListener('click', ()=>{
    const txt = document.getElementById('result').textContent;
    navigator.clipboard.writeText(txt).then(()=>{
      alert('âœ… ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }).catch(err=>{
      alert('ğŸš« ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
    });
  });

  document.getElementById('clear').addEventListener('click', ()=>{
    document.getElementById('input').value = '';
    document.getElementById('result').textContent = '(ì•„ì§ ê³„ì‚°í•˜ì§€ ì•ŠìŒ)';
  });
  
</body>
</html>
